  Introduction The Digital Victorian Periodical Poetry (DVPP) project is a SSHRC-funded digital humanities                project based at the University of Victoria. With the guidance of principal investigator Dr. Alison Chapman, the DVPP team is creating                a digital index of British periodical poetry from the long nineteenth century. In addition to uncovering periodical poems, writing                descriptive metadata, and compiling prosopographical research, we are currently using TEI and CSS to encode a                statistically-representative sample of indexed poems, looking for quantitative evidence of literary change over time. Such an endeavour                requires a large and robust dataset covering a range of periodicals throughout the period. At the time of writing, there are over 13,000 poems in the database, and we expect that total to reach 20,000. Of these, around 2,000                will be encoded, focusing on the decade years (1820, 1830, 1840 and so on).  When we initially received funding for this project, we were quite confident that we would be able to accomplish the collection of                page-images and metadata across the period, because we had been doing that work for some years and had a clear idea of the time and                resources required. However, a relatively small number of poems had been encoded, and the encoding time required had proved to be                significant. Our first pass of encoding goes beyond simple transcription and tagging of lines and line-groups to include rhyme-schemes and rhyme                types, refrains and similar devices such as anaphora and epistrophe, and detailed description of typographical style and layout using                CSS. These are all features that will form part of the analytic work to be done when the encoding is complete.   Encoding speed improvements (yellow line with triangle markers).  Initial projections from our project diagnostics suggested that we would have some difficulty in accomplishing the tagging task within                the time available, so beginning towards the end of 2018, the encoding team (Fralick, Fukushima, Holmes, and Karlson) began a concerted                effort to develop tools and techniques to make our encoding faster and more effective. The results can be seen in the graph in , taken from our project diagnostics. In this presentation, we will describe and demonstrate some                of the techniques we deployed to make this improvement possible. We hope these examples, illustrations, and suggestions will be useful                to other projects endeavouring to make their encoding process more accurate and efficient.    Automatic headers and OCR First of all, we eliminated all the work of setting up the XML file, completing the core metadata, and doing the transcription. Our                large database index of poetry includes metadata on all the poems, along with links to the page-images in which they appear. A build                process is able to export the SQL database as XML, process it into TEI files, and initiate an OCR process on each file, storing the                results in the form of a comment in the body of the TEI file. This removes the bulk of the transcription work, and relieves the encoder                of any responsibility for the metadata. The quality of the OCR is variable, but in almost all cases, proofing and correcting it is much                faster than transcribing manually ( and ).   The TEI Header generated automatically from the database.    The results of OCR, stored as a comment in the XML.    Auto-tagging of an entire poem After correcting the results of the OCR against the original page-image, the next task for the encoder is to tag the structure of the                poem. Taking advantage of the support for Schematron QuickFix in the Oxygen XML Editor, we are able to completely automate the tagging                of lines and line-groups; the encoder simply has to copy/paste the text version of the poem into a div, right-click, and choose a                quick-fix, and the poem is automatically tagged with lg and l elements ( and ).   A Schematron QuickFix for auto-tagging an entire poem.    The result of applying the Schematron QuickFix.    Keystroke shortcuts with special sauce Among the more straightforward tricks are obviously keystroke shortcuts for inserting special characters and XML tags. In addition to                the basics (Alt + QUOTE to insert a curly apostrophe, Alt + M to insert an em dash) we have also been able to                take advantage of the fact that Oxygen allows the use of XPath in keystroke shortcuts to provide a useful time-saver when tagging                rhyme. Control + Alt + 0 will wrap a rhyme tag around selected text, but it does more than that; it uses XPath                regular expressionsSee . The XPath expression is relatively crude, but it generates                   correct results almost all the time. to analyze the contents of the tag to determine whether the rhyme being tagged is most                likely masculine (one syllable) or feminine (two or more syllables), and applies the appropriate attribute value to the rhyme element. Although                there are of course other varieties of rhyme, in this collection masculine rhymes constitute 84% of the total and feminine rhymes more                than 9%. This little trick therefore provides an accurate rhyme tag more than 90% of the time (                and ).   The encoder selects text, hits the shortcut and provides a label attribute.    The shortcut automatically detects the rhyme type as feminine.    ${selection}${caret}  An Oxygen code template for tagging rhyme.    Rhyme-labelling tools The rhyme-labelling protocols in our project are a little unusual. First, we use both the rhyme attribute on lg to                specify the rhyme pattern for a stanza, and also the label attribute on individual rhyme elements to re-iterate                those labels. This duplication has two functions: first, it is easier to analyze the rhyme-scheme of a stanza while its encoding is                relatively uncluttered, so we do this before adding the rhyme elements to individual lines. Secondly, the duplication acts as                a check on the accuracy of the line-level labelling. If an encoder assigns rhyme=cbcb to the stanza, but then                inadvertently gives the third line label=b, our diagnostic rendering (of which more below) will catch this and                report the error ().   Diagnostic report catching rhyme label inconsistency.   The second respect in which our rhyme-labelling differs from many conventional approaches is that we do not restart our rhyme                labelling from a with every new stanza, as is exemplified for example in the TEI Guidelines chapter on Verse                   (TEI 2019). Instead, we maintain a consistent use of the same label for the same sound                throughout a poem, no matter how long it is. If love is labelled as a in stanza one, then dove will be                labelled a in stanza 57. The reason for this is that we are interested in the effect of rhyme patterns across stanzas as                well as within them. It is certainly arguable that there is no plausible effect on the reader of the repetition of a sound dozens of                stanzas apart, but it is actually more difficult to specify an arbitrary distance beyond which rhyme recurrence is not relevant, and                use such a determination in our encoding, than it is to follow a single sequence throughout the poem.For longer poems, when the                   26 letters of the alphabet are exhausted, we restart with a1, b1, c1 etc., followed by a2, b2, c2 as necessary.  However, this can make rhyme-labelling very difficult in a long poem; it is hard to remember, when encountering night at line                300, that sight and flight were actually rhymed 200 lines earlier and have the label b. Therefore we have                devised a tool based on an XSLT transformation that assists in this process. The encoder specifies the rhyme they are about to tag (say                   night), and the following process is run:  Every instance of the word night tagged as a rhyme throughout the entire collection is collected. This might collect (for                   example) 40 instances of night. For each of those instances, all the rhymes tagged in the same poem with the same label as night are retrieved. This might                   collect 250 words rhyming with night. For each of those rhymes, all instances of those forms tagged as rhymes throughout the collection are retrieved. This might                   garner 300 words plausibly rhyming with night. For each of those rhymes, every form tagged in the same poem with the same label is retrieved. This might yield a total of (say)                   500 forms which probably rhyme with night. Of these, there might be 300 distinct forms (because of course there will be many                   duplicates). Finally, each of the distinct values in the list is checked against previously-tagged rhymes in the poem the encoder is working                   on. If any match, a report is generated as shown in .    POTENTIAL RHYMES FOR night FOUND IN POEM 478600 night (label = b) a | right (label = b) Night (label = b;) blight (label = b)                   flight (label = b;)  Report of previous lines in the same poem which are potential rhymes for the selected text.  The encoder is thus able to see that earlier in their poem, night, aright, Night, blight and flight                have all been tagged with label=b, so that is the appropriate label to use. Since our current collection of                tagged rhymes is now well over 30,000, this tool really facilitates the encoding of longer poems. Sometimes, however, a previous instance of a rhyme may be missed, and instead of being given label=b, a rhyme may                be assigned a new label by mistake. When this is noticed, another transformation can be used to fix the problem. The user runs the                transformation, and supplies the label which was erroneously assigned, along with the correct label; the transformation then re-labels                the entire poem appropriately.   CSS styling with rendition/@selector Throughout the nineteenth century, periodicals published poetry in a wide variety of formats and for many different reasons. Sometimes                poems were mere filler, inserted to avoid whitespace at the end of a prose article; in other cases, they form part of a prose article                on the theme of poetry; sometimes they serve as embellishments for illustrations; and sometimes they are appear as standalone works on                otherwise empty pages. Our researchers are interested in connections between form and function, and the relationships of poems to the                surrounding material, so it is essential that we capture key aspects of the appearance of poems, including alignment, font                styles/variants and size, margins, and indents, and in our HTML rendering of the poems (see below) we try to reproduce this as closely                as possible. In our early encoding, we captured these features using inline @style attributes, but the effect of this is to clutter the                poem text with complex property-value pairs which make the rest of the encoding harder to work with. As a result, we have switched to                using rendition elements in the header, and in particular to the relatively rarely-used selector attribute, which                enables us to describe the layout of a poem extremely efficiently, especially if it follows a regular pattern. For instance:  margin: 0.5em auto 0.5em 6em; margin-left: 1em;  describes the layout of the example poem used in this article fully, positioning the line-groups within the page, and                indenting the second and fourth lines of every stanza. Where initially encoders were spending significant time inserting                   style attributes in multiple locations, they are now skilled at abstracting the layout of a poem into a couple of                   rendition elements in a few seconds.   Instant feedback and error reporting Timely diagnostic checking of encoding is extremely important for any serious encoding project (see Holmes and Takeda 2019). In this project, we have found significant benefit in providing a                detailed rendering and report () for encoders to use as they work, accessible through a                transformation scenario available from a single button click in the Oxygen editor.                   Rendered poem view with feedback report.  This view allows the encoder to see at a glance the layout of the poem (as they have described it in CSS), check the rhymes                (through colour coding and reports on inconsistencies found, as shown in ), as well as providing                additional hints for features not yet encoded, as described in the next section.    Auto-detection of anaphora, epistrophe and other refrain-like devices In addition to rhyme, we are encoding other features that involve repetitive forms and structures, such as full-scale refrains,                anaphora (repeating a word or words at the beginning of a line), and epistrophe (repetition at the end of a line). It is easy for an                encoder to miss such features in the midst of encoding rhyme and layout, so the rendering process includes a component which uses a                simple similarity metric to identify potential instances of these features.  shows the output of                this function as applied to the example poem.                   Potential untagged refrain devices identified by the diagnostic rendering.  Here, lines 1 and 9 are similar enough to be tagged (Awake to the sound of my sighing / Wake then to the sound of                   my sighing), as are lines 2 and 10 (Breeze, gentle breeze of the night / Breeze! quiet breeze of the night).                Similarly, the phrase breeze of the night occurs again in line 14. The automated process enables us to ensure that we catch such                echoes even when they are distant from each other in a long poem, and it also gives us a focus, through the (albeit crude) score                calculation, to discuss and compare what might or might not constitute a real instance of a refrain device.   Conclusion Through a determined focus on developing tools and techniques to improve accuracy and efficiency, we have been able to make a                significant improvement in our encoding performance. This has been achieved through continuous dialog between the encoding team and the                programmer. We encourage encoders to express their difficulties and concerns, identify awkward and time-consuming parts of the process,                and suggest imaginative solutions. We have also been able to leverage the growing dataset of encoding already completed to help with                rhyme encoding in particular. Other significant factors include the instant feedback available as a diagnostic rendering of the poem                while encoding; a project-level diagnostic process which continuously measures and reports on our progress through the dataset; and the                fact that the programmer is also required to do significant amounts of encoding himself, so he encounters first-hand the problems the                team is facing, and the frustrations and inadequacies of the solutions provided so far.  